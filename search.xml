<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>blalala</title>
      <link href="/2020/06/09/blalala/"/>
      <url>/2020/06/09/blalala/</url>
      
        <content type="html"><![CDATA[<p>重返赛场，不赢不归。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>nerverMore</title>
      <link href="/2020/06/09/nerverMore/"/>
      <url>/2020/06/09/nerverMore/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>分析打包大小</p></blockquote><pre><code>yarn analyze</code></pre><h1 id="常用命令：npx-webpack"><a href="#常用命令：npx-webpack" class="headerlink" title="常用命令：npx webpack"></a>常用命令：npx webpack</h1><h1 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h1>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>webpack</title>
      <link href="/2020/05/28/webpack/"/>
      <url>/2020/05/28/webpack/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><blockquote><p>分析打包大小</p></blockquote><pre><code>yarn analyze</code></pre><h1 id="常用命令：npx-webpack"><a href="#常用命令：npx-webpack" class="headerlink" title="常用命令：npx webpack"></a>常用命令：npx webpack</h1><h1 id="webpack-安装"><a href="#webpack-安装" class="headerlink" title="webpack 安装"></a>webpack 安装</h1><blockquote><p>安装本地的webpage</p></blockquote><blockquote><p>webpack webpack-cli-D （-D 表示我们开发环境，上线的不需要）</p></blockquote><h1 id="webpack-可以进行0配置"><a href="#webpack-可以进行0配置" class="headerlink" title="webpack 可以进行0配置"></a>webpack 可以进行0配置</h1><blockquote><p>打包工具 -&gt; 输出后的结果（js模块）</p></blockquote><p>写好js文件，后可以通过命令：npx webpack 来运行产出结果为 dist-&gt; main.js</p><blockquote><p>打包（支持我们的js的模块化）</p></blockquote><h1 id="手动配置webpack"><a href="#手动配置webpack" class="headerlink" title="手动配置webpack"></a>手动配置webpack</h1><blockquote><p>默认配置文件：webpack.config.js</p></blockquote><blockquote><p>手动使用webpack自定义文件–命令–npx webpack –config webpack.config.my.js</p></blockquote><h1 id="开发时–端口"><a href="#开发时–端口" class="headerlink" title="开发时–端口"></a>开发时–端口</h1><blockquote><p>yarn add webpack-dev-server -D  –安装</p></blockquote><blockquote><p>npx webpack-dev-server –启动</p></blockquote><h1 id="问题：每次打包的时候不能一直手动输入HTML"><a href="#问题：每次打包的时候不能一直手动输入HTML" class="headerlink" title="问题：每次打包的时候不能一直手动输入HTML"></a>问题：每次打包的时候不能一直手动输入HTML</h1><blockquote><p>所以引入HTML插件，帮助我们把打包后的东西放入里边</p></blockquote><blockquote><p>命令： yarn add html-webpack-plugin -D</p></blockquote><pre><code>module: {    // loader    rules: [ // 规则 css-loader 解析 @improt这种语法的    // style-loader 他是把css 插入到head的标签中        {            test: /\.css$/,            use:[                {                    loader: &#39;s&#39;                }            ]        },    ]}</code></pre><h1 id="打包自动加前缀（为了兼容）：autoprefixer"><a href="#打包自动加前缀（为了兼容）：autoprefixer" class="headerlink" title="打包自动加前缀（为了兼容）：autoprefixer"></a>打包自动加前缀（为了兼容）：autoprefixer</h1><pre><code>yarn add postcss-loader autoprefixer</code></pre><h1 id="打包压缩css插件：mini-css-extract-plugin-将分散的打包位一个文件"><a href="#打包压缩css插件：mini-css-extract-plugin-将分散的打包位一个文件" class="headerlink" title="打包压缩css插件：mini-css-extract-plugin  (将分散的打包位一个文件)"></a>打包压缩css插件：mini-css-extract-plugin  (将分散的打包位一个文件)</h1><h1 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h1><h1 id="babel-作用：将es6转化为es5"><a href="#babel-作用：将es6转化为es5" class="headerlink" title="babel 作用：将es6转化为es5"></a>babel 作用：将es6转化为es5</h1><blockquote><p>命令：yarn add babel-loader @babel/core @babel/preset-env -D</p></blockquote><h1 id="将class转化为es5"><a href="#将class转化为es5" class="headerlink" title="将class转化为es5"></a>将class转化为es5</h1><blockquote><p>命令：yarn add @babel/plugin-proposal-class-properties –dev</p></blockquote><h1 id="类前边的装饰器"><a href="#类前边的装饰器" class="headerlink" title="类前边的装饰器"></a>类前边的装饰器</h1><blockquote><p>@babel/plugin-proposal-decorators<br>@babel/plugin-proposal-class-properites</p></blockquote><h1 id="js-中解析es6-es7语法"><a href="#js-中解析es6-es7语法" class="headerlink" title="js 中解析es6 es7语法"></a>js 中解析es6 es7语法</h1><blockquote><p>用来es6 转化 es5 语法的包：例如class 和 generator 这种高级语法的转化</p></blockquote><pre><code>@babel/plugin-transform-runtime@babel/runtimeyarn add @babel/plugin-transform-runtime -Dyarn add @babel/runtime </code></pre><blockquote><p>实例中方法的解析，例如：”aaa”.includes(‘a’);</p></blockquote><pre><code>yarn add @babel/polyfill</code></pre><h1 id="js-校验-工具：eslint"><a href="#js-校验-工具：eslint" class="headerlink" title="js 校验 工具：eslint"></a>js 校验 工具：eslint</h1><pre><code>yarn add eslint eslint-loader</code></pre><pre><code>expose-loader 暴露 全局的loader  内联的loaderpre 前边执行的loadernormal 普通loader内联 loaderpostloader 后置</code></pre><h1 id="Jquery-暴露全局的方法，和在每个文件加上-（有三张方法）"><a href="#Jquery-暴露全局的方法，和在每个文件加上-（有三张方法）" class="headerlink" title="Jquery :暴露全局的方法，和在每个文件加上$（有三张方法）"></a>Jquery :暴露全局的方法，和在每个文件加上$（有三张方法）</h1><pre><code>1. expose-loader 暴露到window上2. providePlugin 给每个人提供一个$3. 引入不打包</code></pre><blockquote><p>config.js</p></blockquote><pre><code>let webpack = require(&#39;webpack&#39;);new webpack.ProvidePlugin({    $:&#39;jquery&#39;})</code></pre><h1 id="webpakck打包我们的图片"><a href="#webpakck打包我们的图片" class="headerlink" title="webpakck打包我们的图片"></a>webpakck打包我们的图片</h1><pre><code>1.在js中创建图片来引入；2.在css引入 background(&#39;url&#39;);3.&lt;img src=&#39;&#39; alt=&#39;&#39; /&gt;</code></pre><blockquote><p>file-loader 默认会在内部生成一张图片，到build目录下,把生成的图片的名字返回回来；</p></blockquote><pre><code>在html中插入img标签的时候用的loaderyarn add html-withimg-loader -D目前不关用不知道为啥</code></pre><p>图片也可以转成base64这样的话就不用多发http请求，但是转成base64格式会比之前的文件大一些；</p><pre><code>yarn add url-loader -D</code></pre><pre><code>rules:[  {    test: /\.(png|jpg|gif)$/,    // 做一个限制，当我们图片小鱼多少k的时候 用base64来转化，    // 否则用 file-loader 产生真是的图片    use: {      // loader: &#39;file-loader&#39;      loader: &#39;url-loader&#39;,      options: {        limit: 200*1024,        outputPath: &#39;img/&#39;      }    }  },]</code></pre><p>给图片加上路径</p><pre><code>publicPath: &#39;http://www.acv.comoutput: {    filename: &#39;index.[hash:8].js&#39;, // 打包后的文件名    path: path.resolve(__dirname, &#39;build&#39;),    // publicPath: &#39;http://www.acv.com&#39;},rules:[ {    test: /\.(png|jpg|gif)$/,    use: {      // loader: &#39;file-loader&#39;      loader: &#39;url-loader&#39;,      options: {        limit: 200*1024,        outputPath: &#39;img/&#39;,        publicPath: &#39;http:www.guoyongheng.cn&#39; // 只给图片加路径，其他不加      }    }  },]</code></pre><h1 id="打包多页面应用"><a href="#打包多页面应用" class="headerlink" title="打包多页面应用"></a>打包多页面应用</h1><pre><code>初始化： yarn init -y安装webpack： yarn add webpack webpack-cli</code></pre><pre><code>module.exports = {  // 多入口  mode: &#39;development&#39;,  entry: {    home: &#39;./src/index.js&#39;,    other: &#39;./src/other.js&#39;,  },  // entry: &#39;./src/index.js&#39;, // 入口  output: {    // [name] home,other    filename: &#39;[name].js&#39;,    path: path.resolve(__dirname, &#39;dist&#39;)  },  plugins:[    new HtmlWebpackPlugin({      template: &#39;./index.html&#39;,      filename: &#39;home.html&#39;,      chunks: [&#39;home&#39;]    }),    new HtmlWebpackPlugin({      template: &#39;./index.html&#39;,      filename: &#39;other.html&#39;,      chunks: [&#39;other&#39;]    })  ]}</code></pre><h1 id="source-map"><a href="#source-map" class="headerlink" title="source-map"></a>source-map</h1><pre><code>yarn add @babel/core @babel/preset-env babel-loader webpack-dev-server -D</code></pre><pre><code>// 1) 源码映射 会单独生成一个sourcemap 文件 出错了 会标识当前报错的列和行   大  全devtool: &#39;source-map&#39;// 增加映射文件 可以帮我们调试源代码// 2) 不会产生单独的文件，但是可以显示行和列devtool: &#39;eval-source-map&#39;// 3） 不会产生列 但是是一个单独的映射文件devtool: &#39;cheap-module-source-map&#39;（这个用的一般不多）// 4） 不会产生文件 集成在打包后的文件中 不会产生列devtool: &#39;cheap-module-eval-source-map&#39;</code></pre><h1 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h1><blockquote><p>目的：用来检测代码的变化，从而自动打包</p></blockquote><pre><code>module.exports = {  watch: true,  watchOptions: { // 监控的选项    poll: 1000, // 每秒 问我 1000次    aggregateTimeout: 500, // 防抖 我一直输入代码    ignored: /node_modules/  // 不需要监控  },}</code></pre><h1 id="15-webpack小插件"><a href="#15-webpack小插件" class="headerlink" title="15. webpack小插件"></a>15. webpack小插件</h1><ol><li>cleanWebpackPlugin</li><li>copyWebpackPlugin</li><li>bannerPlugin  内置</li></ol><pre><code>命令： yarn add clean-webpack-plugin -Dconst { CleanWebpackPlugin } = require(&#39;clean-webpack-plugin&#39;)plugins: [    new CleanWebpackPlugin(&#39;./dist&#39;)  ]</code></pre><pre><code>let CopyWebpackPlugin  =require(&#39;copy-webpack-plugin&#39;)plugins: [ new CopyWebpackPlugin([      {from: &#39;./doc&#39;, to: &#39;./&#39;}    ])]</code></pre><pre><code>let webpack = require(&#39;webpack&#39;)plugins: [    new webpack.BannerPlugin(&#39;make 2020/09/8&#39;)]</code></pre><h1 id="15-webpack跨域问题"><a href="#15-webpack跨域问题" class="headerlink" title="15. webpack跨域问题"></a>15. webpack跨域问题</h1><pre><code>webpack题内置express，可用server.js文件配置，然后run code </code></pre><p>server.js</p><pre><code>// expresslet express = require(&#39;express&#39;);let app = express();app.get(&#39;/api/user&#39;, (req, res) =&gt; {  res.json({name: &#39;HCM第一帅&#39;})})app.listen(3000)</code></pre><p>webpack.config.js</p><pre><code>module.exports = {  // TODO  devServer:{    proxy: {      &#39;/api&#39;: &#39;http://localhost:3000&#39; //配置了一个代理    }  },}</code></pre><p>由于前端采用/api/user，但是后端不一定是这样，有可能是/user，这时候需要转换一下</p><pre><code>  devServer: {    // proxy: {    //   &#39;/api&#39;: &#39;http://localhost:3000&#39; //配置了一个代理    // }    proxy: {      &#39;/api&#39;: {        target: &#39;http://localhost:3000&#39;,        pathRewrite: {          &#39;/api&#39;: &#39;&#39;        }      }    }  },</code></pre><pre><code>  devServer: {    // 2) 我们前端只想单纯来模拟数据    before(app){      app.get(&#39;/user&#39;, (req, res) =&gt; {        res.json({name: &#39;HCM第一帅--before&#39;})      })    },</code></pre><h2 id="第三种方法"><a href="#第三种方法" class="headerlink" title="第三种方法"></a>第三种方法</h2><pre><code>  devServer: {    // 3) 有服务端 不用代理来处理 能不能再服务端启动webpack 端口用服务区端口    }</code></pre><p>命令： yarn add webpack-dev-middleware -D<br>server.js</p><pre><code>// TODO   expresslet express = require(&#39;express&#39;);let app = express();let webpack = require(&#39;webpack&#39;);// 中间件let middle = require(&#39;webpack-dev-middleware&#39;);let config = require(&#39;./webpack.config&#39;);let compiler = webpack(config);app.use(middle(compiler));app.get(&#39;/user&#39;, (req, res) =&gt; {  res.json({name: &#39;HCM第一帅!!!&#39;})})app.listen(3000)</code></pre><p>上述配置写完之后<br>命令： node server.js</p><h1 id="17-resolve-解析"><a href="#17-resolve-解析" class="headerlink" title="17.resolve //解析"></a>17.resolve //解析</h1><pre><code>  resolve: { //解析    modules: [path.resolve(&#39;node_modules&#39;)],     alias: { // 别名，因为引入文件太长，可以配置成简单的      bootstrap: &#39;bootstrap/dist/css/bootstrap.css&#39;    }  },</code></pre><pre><code>  resolve: { //解析    modules: [path.resolve(&#39;node_modules&#39;)],     mainFields: [&#39;style&#39;, &#39;main&#39;], //可以规定先找style 后找main    // alias: { // 别名，因为引入文件太长，可以配置成简单的    //   bootstrap: &#39;bootstrap/dist/css/bootstrap.css&#39;    // }  },</code></pre><pre><code>  resolve: { //解析    modules: [path.resolve(&#39;node_modules&#39;)],     // mainFields: [&#39;style&#39;, &#39;main&#39;], //可以规定先找style 后找main    mainFiles: [],// 入口文件的名字 index.js    // alias: { // 别名，因为引入文件太长，可以配置成简单的    //   bootstrap: &#39;bootstrap/dist/css/bootstrap.css&#39;    // }  },</code></pre><p>有时候我们为了引入的时候不写后缀名<br>：比如 import ‘./style’</p><pre><code>  resolve: { //解析    modules: [path.resolve(&#39;node_modules&#39;)],     extensions: [&#39;.js&#39;,&#39;.css&#39;, &#39;.json&#39;], //先找js，依次类推    // mainFields: [&#39;style&#39;, &#39;main&#39;], //可以规定先找style 后找main    // mainFiles: [],// 入口文件的名字 index.js    // alias: { // 别名，因为引入文件太长，可以配置成简单的    //   bootstrap: &#39;bootstrap/dist/css/bootstrap.css&#39;    // }  },</code></pre><h1 id="18-定义环境变量"><a href="#18-定义环境变量" class="headerlink" title="18.定义环境变量"></a>18.定义环境变量</h1><pre><code>  plugins: [    // TODO    new webpack.DefinePlugin({      DEV: JSON.stringify(&#39;production&#39;), //console.log( dev); 开发环境dev还是生产      FLAG: &#39;true&#39;,      EXPORESSION: &#39;1+1&#39;    }),  ]    </code></pre><h1 id="19-区分不同的环境"><a href="#19-区分不同的环境" class="headerlink" title="19.区分不同的环境"></a>19.区分不同的环境</h1><blockquote><p>一般会写两个webpack文件：webpack.dev.js webpack.prod.js<br>webpack.base.js 由原来的webpack.config.js变化而来</p></blockquote><p>webpack.dev.js</p><pre><code>let { smart } = require(&#39;webpack-merge&#39;);let base = require(&#39;./webpack.base.js&#39;);module.exports = smart(base, {  mode: &#39;development&#39;,  devServer: {  },  devtool: &#39;source-map&#39;})</code></pre><p>webpack.prod.js </p><pre><code>let {smart} = require(&#39;webpack-merge&#39;);let base =require(&#39;./webpack.base.js&#39;);module.exports = smart(base, {  mode: &#39;production&#39;,  optimization: {    minimize: [    ]  }})</code></pre><p>安装命令： yarn add webpack-merge -D<br>运行命令：npm run build – –config webpack.dev.js</p><h1 id="20-noParse"><a href="#20-noParse" class="headerlink" title="20 noParse"></a>20 noParse</h1><pre><code>module: {    noParse: /jquery/,  // 不去解析jquery中的依赖库    exclude: /node_modules/, //    include: path.resolve(&#39;src&#39;),}</code></pre><p>用来优化webapck打包速度，</p><h1 id="20-IgnorePlugin"><a href="#20-IgnorePlugin" class="headerlink" title="20 IgnorePlugin"></a>20 IgnorePlugin</h1><pre><code>  plugins: [    new webpack.IgnorePlugin(/\.\/locale/, /moment/),  ]</code></pre><h1 id="dullPlugin"><a href="#dullPlugin" class="headerlink" title="dullPlugin"></a>dullPlugin</h1><pre><code>  output: {    // [name] home,other    filename: &#39;_dll_[name].js&#39;,    path: path.resolve(__dirname, &#39;dist&#39;),    library: &#39;_dll_[name]&#39;,    libraryTarget: &#39;commonjs&#39; // var umd var this ...  },  plugins: [    new webpack.DllPlugin({      name: &#39;_dll_[name].js&#39;,      path: path.resolve(__dirname, &#39;dist&#39;, &#39;manifest,json&#39;)    })  ]</code></pre><p>webpack.config.js</p><pre><code>    plugins: [    // TODO    new webpack.DllReferencePlugin({      manifest: path.resolve(__dirname, &#39;dist&#39;, &#39;manifest.json&#39;)    }),</code></pre><p>相关命令： npx webpack –config webpack.config.react.js</p><h1 id="23-happypack"><a href="#23-happypack" class="headerlink" title="23.happypack"></a>23.happypack</h1><h1 id="24-webpack自带优化"><a href="#24-webpack自带优化" class="headerlink" title="24.webpack自带优化"></a>24.webpack自带优化</h1><p>a.js</p><pre><code>const bconst cexport default {b,c}</code></pre><pre><code>import a from &#39;./a.js&#39;console.log(a.b());这时候打包只打包 b 还是c也打包呢？答案：//import语法 dev下都有，生产环境会过滤掉没有用到的部分//这种模式叫 tree-shaking 把没用到的代码 自动删除掉require 没有这种功能//这就是前端为什么要使用import语法// scope hosting 作用域提升let a = 1;let b = 2;let c = 3;let d =a+b+c;// 在webpack中自动省却 可以简化的代码console.log(d,&#39;------------&#39;)最后出来的console是webpack自己打包出来的，而不是浏览器算出来的</code></pre><h1 id="25-抽离公共代码"><a href="#25-抽离公共代码" class="headerlink" title="25. 抽离公共代码"></a>25. 抽离公共代码</h1><blockquote><p>问题:如果有两个js文件，他们都同时引入了一个同一个js文件，那么这个js文件是不是要被引用两次？</p></blockquote><pre><code>module.exports = {  optimization:{ // commonChunkPlugins    splitChunks: { // 分割代码块      cacheGroups:{ // 缓存组 cacheGroups?,         common: { // 公共的模块          chunks: &#39;initial&#39;,          minSize: 0,          minChunks: 2,        },        vendor: {          priority:1, // 权重 ：代表先执行 第三方模块的抽离，再对代码块抽离          test: /node_modules/, // 把你抽离          chunks: &#39;initial&#39;,          minSize: 0,          minChunks: 2,        }      }    }  },}</code></pre><h1 id="26-懒加载"><a href="#26-懒加载" class="headerlink" title="26. 懒加载"></a>26. 懒加载</h1><blockquote><p>用到的插件<br>index.js</p></blockquote><pre><code>// es6 草案中的语法， jsonp实现动态加载文件import(&#39;./source.js&#39;).then(data =&gt; {    console.log(data.default)})</code></pre><p>yarn add @babel/plugin-syntax-dynamic-import -D<br>然后在相应webpack.config.js上 </p><pre><code>plugins: [    &#39;@babel/plugin-syntax-dynamic-import&#39;]</code></pre><h1 id="27-热更新"><a href="#27-热更新" class="headerlink" title="27. 热更新"></a>27. 热更新</h1><p>其实是增量刷新，页面没有刷新打圈圈</p><pre><code>  devServer: {    hot: true, //TODO 启用热更新    port: 3000,    open: true,    contentBase: &#39;./dist&#39;,  },  new webpack.NamedModulesPlugin(),//todo 打印更新的模块路径    new webpack.HotModuleReplacementPlugin() //todo 热更新插件</code></pre><h1 id="28-tapable"><a href="#28-tapable" class="headerlink" title="28. tapable"></a>28. tapable</h1><p>yarn add tapale</p><blockquote><p>这个其中用到了发布订阅，很重要</p></blockquote><pre><code>// TODO 订阅发布 class SyncHook {  // 同步钩子  constructor(args){ // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tap(name, task){    this.tasks.push(task);  }  call(...args){    this.tasks.forEach(task =&gt; task(...args));  }}let hook = new SyncHook([&#39;name&#39;]);hook.tap(&#39;react&#39;, function name(name) {  console.log(&#39;react: &#39;, name);})hook.tap(&#39;node&#39;, function name(name) {  console.log(&#39;node: &#39;, name);})hook.call(&#39;jw&#39;);</code></pre><blockquote><p>tap向数组中追加方法，call调用数组中的方法</p></blockquote><h1 id="29-tapable"><a href="#29-tapable" class="headerlink" title="29. tapable"></a>29. tapable</h1><blockquote><p>// 同步保险钩子:SyncBailHook</p></blockquote><pre><code>class SyncBailHook {    constructor(args){ // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tap(name, task){    this.tasks.push(task);  }  call(...args){    let ret; // 当前这个函数的返回    let index = 0; //当前要执行第一个    while (ret === undefined &amp;&amp; index &lt; this.tasks.length) {      ret = this.tasks[index++](...args)    }  }}let hook = new SyncBailHook([&#39;name&#39;]);hook.tap(&#39;react&#39;, function name(name) {  console.log(&#39;react: &#39;, name);  return &#39;停止乡下运行&#39;})hook.tap(&#39;node&#39;, function name(name) {  console.log(&#39;node: &#39;, name);})hook.call(&#39;jw&#39;);</code></pre><blockquote><p>waterfall 瀑布</p></blockquote><pre><code>// TODO 订阅发布class SyncWaterfallHook {  constructor(args){ // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tap(name, task){    this.tasks.push(task);  }  call(...args){    let [first, ...others] = this.tasks;    let  ret = first(...args);    others.reduce((a,b) =&gt; {      return b(a)    }, ret)  }}let hook = new SyncWaterfallHook([&#39;name&#39;]);hook.tap(&#39;react&#39;, function name(name) {  console.log(&#39;react: &#39;, name);  return &#39;reactOK&#39;})hook.tap(&#39;node&#39;, function name(data) {  console.log(&#39;node: &#39;, data);  return &#39;NODEok&#39;})hook.tap(&#39;Webpack&#39;, function name(data) {  console.log(&#39;data: &#39;, data);})hook.call(&#39;jw&#39;);</code></pre><blockquote><p>同步遇到某个不反悔undefined的监听函数会多次执行</p></blockquote><pre><code>// TODO 订阅发布class SyncLoopllHook {  constructor(args){ // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tap(name, task){    this.tasks.push(task);  }  call(...args){    this.tasks.forEach(task =&gt; {      let ret;      do {        ret = task(...args)      } while (ret != undefined);    })  }}let hook = new SyncLoopllHook([&#39;name&#39;]);let num = 0hook.tap(&#39;react&#39;, function name(name) {  console.log(&#39;react: &#39;, name);  return  ++num === 3? undefined:&#39;继续学&#39;})hook.tap(&#39;node&#39;, function name(name) {  console.log(&#39;node: &#39;, name);})hook.tap(&#39;Webpack&#39;, function name(name) {  console.log(&#39;Webpack: &#39;, name);})hook.call(&#39;jw&#39;);</code></pre><h1 id="30-AsyncHooks"><a href="#30-AsyncHooks" class="headerlink" title="30. AsyncHooks"></a>30. AsyncHooks</h1><blockquote><p>异步钩子</p></blockquote><pre><code>// TODO 订阅发布 异步AsyncLoopllHookclass AsyncLoopllHook {  constructor(args){ // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tapAsync(name, task){    this.tasks.push(task);  }  callAsync(...args){    let finalCallback = args.pop(); //拿出最终的函数    let index = 0;    let done = () =&gt; {      index++;      if (index == this.tasks.length) {        finalCallback();      }    }    this.tasks.forEach(task =&gt; {      task(...args, done);    })  }}let hook = new AsyncLoopllHook([&#39;name&#39;]);let total = 0hook.tapAsync(&#39;react&#39;, function name(name,cb) {  setTimeout(() =&gt;{    console.log(&#39;react&#39;, name)    cb();  }, 1000)})hook.tapAsync(&#39;node&#39;, function name(name, cb) {  setTimeout(() =&gt;{    console.log(&#39;react&#39;, name)    cb();  }, 1000)})hook.callAsync(&#39;jw&#39;, function (params) {  console.log(&#39;end&#39;);});</code></pre><blockquote><p> tapable库中有三种注册方法<br>tap<br>tapAsync<br>tapPromise<br>// 调用 三种方法 call callAsync promise</p></blockquote><p>异步并发</p><pre><code>// TODO 订阅发布 异步AsyncLoopllHookclass AsyncLoopllHook {  constructor(args){ // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tapPromise(name, task){    this.tasks.push(task);  }  promise(...args){    let tasks = this.tasks.map(task =&gt; task(...args));    return Promise.all(tasks);    // return Promise.all(this.tasks);  }}let hook = new AsyncLoopllHook([&#39;name&#39;]);let total = 0hook.tapPromise(&#39;react&#39;, function name(name) {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt;{      console.log(&#39;react&#39;, name);      resolve();    }, 1000)  })})hook.tapPromise(&#39;node&#39;, function name(name) {  return new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt;{      console.log(&#39;node&#39;, name);      resolve();    }, 1000)  })})hook.promise(&#39;jw&#39;).then(function(){  console.log(&#39;end&#39;)})</code></pre><h1 id="31-异步串行"><a href="#31-异步串行" class="headerlink" title="31. 异步串行"></a>31. 异步串行</h1><blockquote><p>AsyncSeriesHook</p></blockquote><pre><code>// TODO 订阅发布 异步串行 AsyncSeriesclass AsyncSeries {  constructor(args) { // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tapAsync(name, task) {    this.tasks.push(task);  }  callAsync(...args) {    console.log(&#39;args: &#39;, args);    let finalCallback = args.pop();    let index = 0;    let next = () =&gt; {      if (this.tasks.length === index) {        return finalCallback();      }      let task = this.tasks[index++];      task(...args, next);    }    next();  }}let hook = new AsyncSeries([&#39;name&#39;]);let total = 0hook.tapAsync(&#39;react&#39;, function name(name, cb) {  setTimeout(() =&gt; {    console.log(&#39;react&#39;, name);    cb();  }, 1000)})hook.tapAsync(&#39;node&#39;, function name(name, cb) {  setTimeout(() =&gt; {    console.log(&#39;node&#39;, name);    cb();  }, 1000)})hook.callAsync(&#39;HCM第一帅&#39;, function () {  console.log(&#39;end&#39;)})</code></pre><blockquote><p> 异步串行 AsyncSeries</p></blockquote><pre><code>// TODO 订阅发布 异步串行 AsyncSeriesclass AsyncSeries {  constructor(args) { // args =&gt; [&#39;name&#39;]    this.tasks = [];  }  tapPromise(name, task) {    this.tasks.push(task);  }  promise(...args) {    let [first, ...others] = this.tasks;    return others.reduce((a, b) =&gt; { // redux 源码      return a.then(() =&gt; b(...args))    }, first(...args))  }}let hook = new AsyncSeries([&#39;name&#39;]);let total = 0hook.tapPromise(&#39;react&#39;, function name(name) {  return new Promise((rolove, reject) =&gt; {    setTimeout(() =&gt; {      console.log(&#39;react&#39;, name);      rolove();    }, 1000)  })})hook.tapPromise(&#39;node&#39;, function name(name) {  return new Promise((rolove, reject) =&gt; {    setTimeout(() =&gt; {      console.log(&#39;node&#39;, name);      rolove();    }, 1000)  })})hook.promise(&#39;HCM第一帅&#39;).then(function () {  console.log(&#39;end&#39;)})</code></pre><h1 id="32-异步串行钩子函数"><a href="#32-异步串行钩子函数" class="headerlink" title="32.异步串行钩子函数"></a>32.异步串行钩子函数</h1><pre><code></code></pre><h1 id="35"><a href="#35" class="headerlink" title="35."></a>35.</h1><pre><code></code></pre><h1 id="36"><a href="#36" class="headerlink" title="36."></a>36.</h1><pre><code></code></pre><h1 id="41-loader-配置"><a href="#41-loader-配置" class="headerlink" title="41 loader 配置"></a>41 loader 配置</h1><blockquote><p>loader的分类，pre 在前边 post 在后面， normal<br>loader的顺序， pre + normal +inline + post</p></blockquote><pre><code>从右向左，从下到上</code></pre><h1 id="42"><a href="#42" class="headerlink" title="42"></a>42</h1><blockquote><p>babel-loader的实现 </p></blockquote><pre><code>@babel/preset-env 高级语法转换成低级语法</code></pre><h1 id="loader作用"><a href="#loader作用" class="headerlink" title="loader作用"></a>loader作用</h1><pre><code>css-loader 是用来解析里边的css里边的一些，比如：@color: red;body{    background: @color;    background: url(&#39;./public.jpg&#39;)}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端webpack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/05/17/hello-world/"/>
      <url>/2020/05/17/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code>$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code>$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> pythton </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 初来乍到 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
